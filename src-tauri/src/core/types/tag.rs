//! Tag system types
//! 
//! Defines structures for the intelligent tagging system.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

#[cfg(test)]
use proptest::prelude::*;
#[cfg(test)]
use proptest_derive::Arbitrary;

/// Tag definition
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Tag {
    /// Tag unique identifier
    #[cfg_attr(test, proptest(strategy = "any::<u128>().prop_map(|n| Uuid::from_u128(n))"))]
    pub id: Uuid,
    
    /// Tag name (supports multiple languages)
    #[cfg_attr(test, proptest(strategy = "\"[a-zA-Z0-9_]{1,30}\""))]
    pub name: String,
    
    /// Tag display name (localized)
    #[cfg_attr(test, proptest(strategy = "proptest::collection::hash_map(\"[a-z]{2}\", \"[a-zA-Z0-9 ]{1,20}\", 0..3)"))]
    pub display_name: HashMap<String, String>, // locale -> name
    
    /// Parent tag ID (for hierarchy)
    #[cfg_attr(test, proptest(strategy = "proptest::option::of(any::<u128>().prop_map(|n| Uuid::from_u128(n)))"))]
    pub parent_id: Option<Uuid>,
    
    /// Tag type
    pub tag_type: TagType,
    
    /// Tag color (Hex)
    #[cfg_attr(test, proptest(strategy = "\"#[0-9a-fA-F]{6}\""))]
    pub color: String,
    
    /// Tag icon (emoji or icon name)
    #[cfg_attr(test, proptest(strategy = "proptest::option::of(\"[a-z_]{1,10}\")"))]
    pub icon: Option<String>,
    
    /// Whether this is a system tag (cannot be deleted)
    pub is_system: bool,
    
    /// Creation time
    #[cfg_attr(test, proptest(strategy = "any::<i64>().prop_map(|ts| DateTime::from_timestamp(ts.abs() % 4102444800, 0).unwrap_or_else(|| Utc::now()))"))]
    pub created_at: DateTime<Utc>,
    
    /// Usage count (for sorting)
    pub usage_count: u64,
}

/// Tag type classification
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(test, derive(Arbitrary))]
pub enum TagType {
    /// Category tags (Work, Personal, Study)
    Category,
    /// File type tags (Documents, Images, Code)
    FileType,
    /// Project tags
    Project,
    /// Status tags (In Progress, Completed)
    Status,
    /// User-defined custom tags
    Custom,
    /// AI auto-generated tags
    AutoGenerated,
}

/// File-tag relationship
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct FileTagRelation {
    /// Relation ID
    #[cfg_attr(test, proptest(strategy = "any::<u128>().prop_map(|n| Uuid::from_u128(n))"))]
    pub id: Uuid,
    
    /// File ID
    #[cfg_attr(test, proptest(strategy = "any::<u128>().prop_map(|n| Uuid::from_u128(n))"))]
    pub file_id: Uuid,
    
    /// Tag ID
    #[cfg_attr(test, proptest(strategy = "any::<u128>().prop_map(|n| Uuid::from_u128(n))"))]
    pub tag_id: Uuid,
    
    /// Relation source
    pub source: TagSource,
    
    /// Confidence score (for AI-generated)
    #[cfg_attr(test, proptest(strategy = "proptest::option::of(0.0f32..1.0)"))]
    pub confidence: Option<f32>,
    
    /// Whether confirmed by user
    pub is_confirmed: bool,
    
    /// Whether rejected by user (for learning)
    pub is_rejected: bool,
    
    /// Creation time
    #[cfg_attr(test, proptest(strategy = "any::<i64>().prop_map(|ts| DateTime::from_timestamp(ts.abs() % 4102444800, 0).unwrap_or_else(|| Utc::now()))"))]
    pub created_at: DateTime<Utc>,
    
    /// User action time (confirm/reject)
    #[cfg_attr(test, proptest(strategy = "proptest::option::of(any::<i64>().prop_map(|ts| DateTime::from_timestamp(ts.abs() % 4102444800, 0).unwrap_or_else(|| Utc::now())))"))]
    pub user_action_at: Option<DateTime<Utc>>,
}

/// Source of tag assignment
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(test, derive(Arbitrary))]
pub enum TagSource {
    /// User manually added
    Manual,
    /// AI auto-generated
    AIGenerated,
    /// Inherited from parent directory
    Inherited,
    /// Imported from external source
    Imported,
}


#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(100))]
        
        /// **Feature: neural-fs-core, Property 17: Tag Serialization Round-Trip**
        /// *For any* valid Tag, serializing then deserializing should produce an equivalent object
        /// **Validates: Requirements 21**
        #[test]
        fn prop_tag_json_roundtrip(tag in any::<Tag>()) {
            // Serialize to JSON
            let json = serde_json::to_string(&tag).expect("Failed to serialize Tag to JSON");
            
            // Deserialize back
            let deserialized: Tag = serde_json::from_str(&json).expect("Failed to deserialize Tag from JSON");
            
            // Verify equality
            prop_assert_eq!(tag, deserialized);
        }
        
        /// **Feature: neural-fs-core, Property 17: Tag Serialization Round-Trip (bincode)**
        /// *For any* valid Tag, serializing then deserializing with bincode should produce an equivalent object
        /// **Validates: Requirements 21**
        #[test]
        fn prop_tag_bincode_roundtrip(tag in any::<Tag>()) {
            // Serialize to bincode
            let bytes = bincode::serialize(&tag).expect("Failed to serialize Tag to bincode");
            
            // Deserialize back
            let deserialized: Tag = bincode::deserialize(&bytes).expect("Failed to deserialize Tag from bincode");
            
            // Verify equality
            prop_assert_eq!(tag, deserialized);
        }
        
        /// **Feature: neural-fs-core, Property 17: FileTagRelation Serialization Round-Trip**
        /// *For any* valid FileTagRelation, serializing then deserializing should produce an equivalent object
        /// **Validates: Requirements 21**
        #[test]
        fn prop_file_tag_relation_roundtrip(relation in any::<FileTagRelation>()) {
            let json = serde_json::to_string(&relation).expect("Failed to serialize FileTagRelation");
            let deserialized: FileTagRelation = serde_json::from_str(&json).expect("Failed to deserialize FileTagRelation");
            prop_assert_eq!(relation, deserialized);
        }
        
        /// **Feature: neural-fs-core, Property 17: TagType Serialization Round-Trip**
        /// *For any* valid TagType, serializing then deserializing should produce an equivalent value
        /// **Validates: Requirements 21**
        #[test]
        fn prop_tag_type_roundtrip(tag_type in any::<TagType>()) {
            let json = serde_json::to_string(&tag_type).expect("Failed to serialize TagType");
            let deserialized: TagType = serde_json::from_str(&json).expect("Failed to deserialize TagType");
            prop_assert_eq!(tag_type, deserialized);
        }
        
        /// **Feature: neural-fs-core, Property 17: TagSource Serialization Round-Trip**
        /// *For any* valid TagSource, serializing then deserializing should produce an equivalent value
        /// **Validates: Requirements 21**
        #[test]
        fn prop_tag_source_roundtrip(source in any::<TagSource>()) {
            let json = serde_json::to_string(&source).expect("Failed to serialize TagSource");
            let deserialized: TagSource = serde_json::from_str(&json).expect("Failed to deserialize TagSource");
            prop_assert_eq!(source, deserialized);
        }
    }
}
